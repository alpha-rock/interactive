"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.flexGridItemStyle = exports.getResponsiveValue = exports.flexGridItemMediaQueryStyle = void 0;

var React = _interopRequireWildcard(require("react"));

var _index = require("../block/index.js");

var _overrides = require("../helpers/overrides.js");

var _responsiveHelpers = require("../helpers/responsive-helpers.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var flexGridItemMediaQueryStyle = function flexGridItemMediaQueryStyle(_ref) {
  var $theme = _ref.$theme,
      flexGridColumnCount = _ref.flexGridColumnCount,
      flexGridColumnGap = _ref.flexGridColumnGap,
      flexGridRowGap = _ref.flexGridRowGap;
  var colCount = flexGridColumnCount; // 0px needed for calc() to behave properly

  var colGap = $theme.sizing[flexGridColumnGap] || flexGridColumnGap || '0px';
  var colGapQuantity = parseFloat(colGap);
  var colGapUnit = colGap.match(/[a-zA-Z]+/)[0];
  var rowGap = $theme.sizing[flexGridRowGap] || flexGridRowGap || '0px';
  var widthCalc = "(100% - ".concat((colCount - 1) * colGapQuantity).concat(colGapUnit, ") / ").concat(colCount);
  var marginDirection = $theme.direction === 'rtl' ? 'marginLeft' : 'marginRight';
  return _objectSpread({
    // Subtract .5px to avoid rounding issues on IE/Edge
    // See https://github.com/uber-web/baseui/pull/1748
    width: "calc(".concat(widthCalc, " - .5px)")
  }, _toConsumableArray(Array(colCount).keys()).reduce(function (acc, i) {
    var _nthChild$concat$c, _objectSpread2;

    return _objectSpread({}, acc, (_objectSpread2 = {}, _defineProperty(_objectSpread2, ":nth-child(".concat(colCount, "n-").concat(i, ")"), (_nthChild$concat$c = {}, _defineProperty(_nthChild$concat$c, marginDirection, i && colGap), _defineProperty(_nthChild$concat$c, "marginBottom", rowGap), _nthChild$concat$c)), _defineProperty(_objectSpread2, ":nth-child(".concat(colCount, "n-").concat(i, "):last-child"), _defineProperty({}, marginDirection, "calc(".concat(i, " * (").concat(colGap, " + ").concat(widthCalc, "))"))), _objectSpread2), _toConsumableArray(Array(i + 1).keys()).reduce(function (acc, j) {
      return _objectSpread({}, acc, _defineProperty({}, ":nth-child(".concat(colCount, "n-").concat(i, "):nth-last-child(").concat(j + 1, ")"), {
        // Remove rowGap below for last row items
        marginBottom: 0
      }));
    }, {}));
  }, {}));
};

exports.flexGridItemMediaQueryStyle = flexGridItemMediaQueryStyle;

var getResponsiveValue = function getResponsiveValue(responsive, i) {
  if (!responsive) {
    return null;
  }

  if (!Array.isArray(responsive)) {
    return responsive;
  }

  return responsive[i] || responsive[responsive.length - 1];
};

exports.getResponsiveValue = getResponsiveValue;

var flexGridItemStyle = function flexGridItemStyle(_ref2) {
  var $flexGridColumnCount = _ref2.$flexGridColumnCount,
      $flexGridColumnGap = _ref2.$flexGridColumnGap,
      $flexGridRowGap = _ref2.$flexGridRowGap,
      $theme = _ref2.$theme;
  var baseFlexGridItemStyle = {
    flexGrow: 1
  };
  var mediaQueries = (0, _responsiveHelpers.getMediaQueries)($theme.breakpoints); // Get the length of the longest responsive array

  var maxResponsiveLength = Math.max.apply(Math, _toConsumableArray([$flexGridColumnCount, $flexGridColumnGap, $flexGridRowGap].map(function (r) {
    return Array.isArray(r) ? r.length : 0;
  }))); // No media queries for non-responsive FlexGrids

  if (maxResponsiveLength < 2) {
    return _objectSpread({}, baseFlexGridItemStyle, flexGridItemMediaQueryStyle({
      $theme: $theme,
      flexGridColumnCount: getResponsiveValue($flexGridColumnCount, 0) || 1,
      flexGridColumnGap: getResponsiveValue($flexGridColumnGap, 0) || 0,
      flexGridRowGap: getResponsiveValue($flexGridRowGap, 0) || 0
    }));
  } // Generate style by iterating up to maxResponsiveLength for each responsive
  // breakpoint. Will end up with styles for one of the following media queries
  // depending on maxResponsiveLength:
  // - {mobile, small}
  // - {mobile, small, medium}
  // - {mobile, small, medium, large}


  return _toConsumableArray(Array(maxResponsiveLength).keys()).reduce(function (acc, i) {
    var _map = [$flexGridColumnCount, $flexGridColumnGap, $flexGridRowGap].map(function (r) {
      return getResponsiveValue(r, i);
    }),
        _map2 = _slicedToArray(_map, 3),
        flexGridColumnCountValue = _map2[0],
        flexGridColumnGapValue = _map2[1],
        flexGridRowGapValue = _map2[2];

    var mediaQuery;

    if (i === 0) {
      // Custom max-width media query for mobile needed so :nth-child styles
      // don't conflict
      mediaQuery = (0, _responsiveHelpers.getMediaQuery)({
        'max-width': "".concat($theme.breakpoints.small - 1, "px")
      });
    } else {
      mediaQuery = mediaQueries[i - 1];
    }

    if (mediaQuery) {
      acc[mediaQuery] = flexGridItemMediaQueryStyle({
        $theme: $theme,
        flexGridColumnCount: flexGridColumnCountValue || 1,
        flexGridColumnGap: flexGridColumnGapValue || 0,
        flexGridRowGap: flexGridRowGapValue || 0
      });
    }

    return acc;
  }, baseFlexGridItemStyle);
};

exports.flexGridItemStyle = flexGridItemStyle;

var FlexGridItem = function FlexGridItem(_ref3) {
  var children = _ref3.children,
      as = _ref3.as,
      overrides = _ref3.overrides,
      flexGridColumnCount = _ref3.flexGridColumnCount,
      flexGridColumnGap = _ref3.flexGridColumnGap,
      flexGridRowGap = _ref3.flexGridRowGap,
      restProps = _objectWithoutProperties(_ref3, ["children", "as", "overrides", "flexGridColumnCount", "flexGridColumnGap", "flexGridRowGap"]);

  var flexGridItemOverrides = {
    Block: {
      style: flexGridItemStyle
    }
  };
  var blockOverrides = overrides ? (0, _overrides.mergeOverrides)(flexGridItemOverrides, overrides) : flexGridItemOverrides;
  return React.createElement(_index.Block, _extends({
    as: as,
    overrides: blockOverrides,
    $flexGridColumnCount: flexGridColumnCount,
    $flexGridColumnGap: flexGridColumnGap,
    $flexGridRowGap: flexGridRowGap,
    "data-baseweb": "flex-grid-item"
  }, restProps), children);
};

var _default = FlexGridItem;
exports.default = _default;