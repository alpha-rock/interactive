function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
Copyright (c) 2018-2019 Uber Technologies, Inc.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
*/
import { ReactWrapper } from 'enzyme';

var getStyles = function getStyles(received) {
  if (received && received instanceof ReactWrapper) {
    if (received.length < 1) {
      throw new Error("Value passed to expect() was an empty enzyme ReactWrapper, expected a single styled component");
    }

    var type = received.type() || '';

    if (type.displayName !== 'MockStyledComponent') {
      throw new Error("toHaveStyleRule can only be called on styled components, instead found ".concat(type));
    }

    var instance = received.instance();
    var state = instance.state || {};
    return state.styles || {};
  }

  throw new Error("toHaveStyleRule can only be called on styled components, instead found ".concat(_typeof(received)));
};

var toHaveStyleRule = function _toHaveStyleRule(
/* eslint-disable-next-line flowtype/no-weak-types */
actual) {
  var _this = this;

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var property = args[0],
      value = args[1];
  var styles;

  try {
    styles = getStyles(actual) || {};
  } catch (err) {
    return {
      pass: false,
      message: function message() {
        return err.message;
      }
    };
  }

  var actualValue = styles[property];
  var pass = value instanceof RegExp ? value.test(actualValue) : value === actualValue;

  var message = function message() {
    return "Expected '".concat(property, "' to match:\n") + "  ".concat(_this.utils.printExpected(value), "\n") + 'Received:\n' + "  ".concat(_this.utils.printReceived(actualValue));
  };

  return {
    pass: pass,
    message: message
  };
};

export default toHaveStyleRule;