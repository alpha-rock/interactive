"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*
Copyright (c) 2018-2019 Uber Technologies, Inc.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
*/
var trim = function trim(str) {
  return str.replace(/^\s+|\s+$/g, '');
};

var isValid = function isValid(value) {
  return typeof value !== 'undefined' && value !== null && value !== '';
};

var defaultProps = {
  filterOption: null,
  ignoreCase: true,
  labelKey: 'label',
  matchPos: 'any',
  matchProp: 'any',
  trimFilter: true,
  valueKey: 'value'
};

var filterOptions = function filterOptions(options, filterValue, excludeOptions, newProps) {
  var internalExcludeOptions = excludeOptions;

  var props = _objectSpread({}, defaultProps, newProps);

  if (props.ignoreCase) {
    filterValue = filterValue.toLowerCase();
  }

  if (props.trimFilter) {
    filterValue = trim(filterValue);
  }

  if (excludeOptions) internalExcludeOptions = excludeOptions.map(function (i) {
    return i[props.valueKey];
  }); // $FlowFixMe

  return options.filter(function (option) {
    if (internalExcludeOptions && internalExcludeOptions.indexOf(option[props.valueKey]) > -1) return false;
    if (props.filterOption) return props.filterOption.call(undefined, option, filterValue);
    if (!filterValue) return true;
    var value = option[props.valueKey];
    var label = option[props.labelKey];
    var hasValue = isValid(value);
    var hasLabel = isValid(label);

    if (!hasValue && !hasLabel) {
      return false;
    }

    var valueTest = hasValue ? String(value) : null;
    var labelTest = hasLabel ? String(label) : null;

    if (props.ignoreCase) {
      valueTest = valueTest ? valueTest.toLowerCase() : valueTest;
      labelTest = labelTest ? labelTest.toLowerCase() : labelTest;
    }

    return props.matchPos === 'start' ? valueTest && props.matchProp !== 'label' && valueTest.substr(0, filterValue.length) === filterValue || labelTest && props.matchProp !== 'value' && labelTest.substr(0, filterValue.length) === filterValue : valueTest && props.matchProp !== 'label' && valueTest.indexOf(filterValue) >= 0 || labelTest && props.matchProp !== 'value' && labelTest.indexOf(filterValue) >= 0;
  });
};

var _default = filterOptions;
exports.default = _default;