function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*
Copyright (c) 2018-2019 Uber Technologies, Inc.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
*/
import { styled } from '../styles/index.js';
var DEFAULT = 0;
var HOVERED = 1;
var ACTIVE = 2;

function getState(props) {
  if (props.$isActive) return ACTIVE;
  if (props.$isHovered) return HOVERED;
  return DEFAULT;
}

function getOuterColor(props) {
  var colors = props.$theme.colors;

  if (!props.$checked) {
    if (props.$disabled) return colors.tickMarkFillDisabled;
    if (props.$isError) return colors.tickBorderError;
    return colors.tickBorder;
  } else {
    if (props.$isError) {
      switch (getState(props)) {
        case DEFAULT:
          return colors.tickFillErrorSelected;

        case HOVERED:
          return colors.tickFillErrorSelectedHover;

        case ACTIVE:
          return colors.tickFillErrorSelectedHoverActive;
      }
    } else {
      if (props.$disabled) return colors.tickFillDisabled;

      switch (getState(props)) {
        case DEFAULT:
          return colors.tickFillSelected;

        case HOVERED:
          return colors.tickFillSelectedHover;

        case ACTIVE:
          return colors.tickFillSelectedHoverActive;
      }
    }
  }

  return null;
}

function getInnerColor(props) {
  var colors = props.$theme.colors;

  if (props.$disabled) {
    return colors.tickMarkFillDisabled;
  }

  if (!props.$checked) {
    if (props.$isError) {
      switch (getState(props)) {
        case DEFAULT:
          return colors.tickFillError;

        case HOVERED:
          return colors.tickFillErrorHover;

        case ACTIVE:
          return colors.tickFillErrorHoverActive;
      }
    } else {
      switch (getState(props)) {
        case DEFAULT:
          return colors.tickFill;

        case HOVERED:
          return colors.tickFillHover;

        case ACTIVE:
          return colors.tickFillActive;
      }
    }
  } else {
    return colors.tickMarkFill;
  }
}

function getLabelPadding(props) {
  var _props$$labelPlacemen = props.$labelPlacement,
      $labelPlacement = _props$$labelPlacemen === void 0 ? '' : _props$$labelPlacemen,
      $theme = props.$theme;
  var paddingDirection;

  switch ($labelPlacement) {
    case 'top':
      paddingDirection = 'Bottom';
      break;

    case 'bottom':
      paddingDirection = 'Top';
      break;

    case 'left':
      paddingDirection = $theme.direction === 'rtl' ? 'Left' : 'Right';
      break;

    default:
    case 'right':
      paddingDirection = $theme.direction === 'rtl' ? 'Right' : 'Left';
      break;
  }

  var sizing = $theme.sizing;
  var scale300 = sizing.scale300;
  return _defineProperty({}, "padding".concat(paddingDirection), scale300);
}

function getLabelColor(props) {
  var $disabled = props.$disabled,
      $theme = props.$theme;
  var colors = $theme.colors;
  return $disabled ? colors.foregroundAlt : colors.foreground;
}

export var RadioGroupRoot = styled('div', function (props) {
  var $disabled = props.$disabled,
      $align = props.$align;
  return {
    flexDirection: $align === 'horizontal' ? 'row' : 'column',
    display: 'flex',
    alignItems: $align === 'horizontal' ? 'center' : 'flex-start',
    cursor: $disabled ? 'not-allowed' : 'pointer'
  };
});
RadioGroupRoot.displayName = "RadioGroupRoot";
export var Root = styled('label', function (props) {
  var $disabled = props.$disabled,
      $hasDescription = props.$hasDescription,
      $labelPlacement = props.$labelPlacement,
      $theme = props.$theme;
  var sizing = $theme.sizing;
  return {
    flexDirection: $labelPlacement === 'top' || $labelPlacement === 'bottom' ? 'column' : 'row',
    display: 'flex',
    alignItems: 'center',
    cursor: $disabled ? 'not-allowed' : 'pointer',
    marginTop: sizing.scale200,
    marginBottom: $hasDescription ? null : sizing.scale200
  };
});
Root.displayName = "Root";
export var RadioMarkInner = styled('div', function (props) {
  var _props$$theme = props.$theme,
      animation = _props$$theme.animation,
      sizing = _props$$theme.sizing;
  return {
    backgroundColor: getInnerColor(props),
    borderTopLeftRadius: '50%',
    borderTopRightRadius: '50%',
    borderBottomRightRadius: '50%',
    borderBottomLeftRadius: '50%',
    height: props.$checked ? sizing.scale200 : sizing.scale600,
    transitionDuration: animation.timing100,
    transitionTimingFunction: animation.easeOutCurve,
    width: props.$checked ? sizing.scale200 : sizing.scale600
  };
});
RadioMarkInner.displayName = "RadioMarkInner";
export var RadioMarkOuter = styled('div', function (props) {
  var sizing = props.$theme.sizing;
  return {
    alignItems: 'center',
    backgroundColor: getOuterColor(props),
    borderTopLeftRadius: '50%',
    borderTopRightRadius: '50%',
    borderBottomRightRadius: '50%',
    borderBottomLeftRadius: '50%',
    display: 'flex',
    height: sizing.scale700,
    justifyContent: 'center',
    marginTop: sizing.scale0,
    marginRight: sizing.scale0,
    marginBottom: sizing.scale0,
    marginLeft: sizing.scale0,
    verticalAlign: 'middle',
    width: sizing.scale700,
    flexShrink: 0
  };
});
RadioMarkOuter.displayName = "RadioMarkOuter";
export var Label = styled('div', function (props) {
  var typography = props.$theme.typography;
  return _objectSpread({
    verticalAlign: 'middle'
  }, getLabelPadding(props), {
    color: getLabelColor(props)
  }, typography.font450);
}); // tricky style for focus event cause display: none doesn't work

Label.displayName = "Label";
export var Input = styled('input', {
  opacity: 0,
  width: 0,
  overflow: 'hidden',
  margin: 0,
  padding: 0,
  position: 'absolute'
});
Input.displayName = "Input";
export var Description = styled('div', function (props) {
  var _objectSpread2;

  return _objectSpread({}, props.$theme.typography.font300, (_objectSpread2 = {
    color: props.$theme.colors.colorSecondary,
    cursor: 'auto'
  }, _defineProperty(_objectSpread2, props.$theme.direction === 'rtl' ? 'marginRight' : 'marginLeft', props.$theme.sizing.scale900), _defineProperty(_objectSpread2, "maxWidth", '240px'), _objectSpread2));
});
Description.displayName = "Description";